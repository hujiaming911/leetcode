Set

添加
set.add()

删除
set.remove()    括号里面直接放想要删除的元素

是否包含
set.contains()

大小
set.size()

遍历
Iterator it=set.iterator();
while(it.hasNext()){
 return (it.next());
}

特殊的TreeSet
TreeSet<Integer> set=new TreeSet<>();
TreeSet会自动排序




Map

添加
map.put()

得到
map.get()

给元素加一常用
map.put(元素，map.getOrDefault(元素,0)+1);

删除
set.remove()  里面放key值

是否包含
map.containsKey()
map.containsValue()

大小
map.size()

遍历
Iterator it=map.entrySet().iterator();
while(it.hasNext()){
   Map.Entry entry=(Map.Entry)it.next();
   System.out.println(entry.getKey()+entry.getValue());
}

不需要Key的遍历
直接map.values()就可以得到所有的value

特殊的map
TreeMap也是特殊的map
Treemap的特殊方法   treemap.lowerKey(val);  得到比val小的最大元素  treemap.higherKey(val); 得到比val大的最小元素
LinkedHashMap相比较与HashMap的不同
LinkedHashMap在遍历时按照加入的顺序遍历，HashMap的遍历时无序的遍历
Map<Integer,Integer> map=new LinkedHashMap<>();






Queue
Queue<String> q=new LinkedList<>();

q.offer()在队列后面填上元素

q.peek()返回头部元素

q.poll()返回并删除头部元素

遍历
不动queue的遍历
for(Integer x:q){
    直接对x进行操作
}
将queue排空的遍历
while(q.peek()!=null){
   q.poll();
}






Stack
Stack<Integer> stack=new Stack<>();

stack.push()压栈

stack.peek()返回头部元素

stack.pop()返回并删除栈顶元素

不动stack的遍历
for(Integer x:stack){
 直接对x进行操作就行 
}
将stack排空的遍历
while(!s.empty()){
   s.pop();
}




ArrayList
List<Integer> list=new ArrayList<>();

添加
list.add();

指定位置添加
list.add(位置，元素) 在指定位置添加，后面的元素往后移

包含
list.contains()

得到元素
list.get()输入的是位置，得到的是元素

得到位置
list.indexOf()输入的是元素，得到的是位置（第一个出现的位置）

删除
list.remove()输入的是元素，删除第一个出现位置上的元素

替换
list.set(位置，元素)替换

特殊
除了有Arrays.sort(数组名)，还可以Collections.sort(list名)，把list里面的数升序排列



String的一些函数
string.substring(6)  得到一个新的string,从原始的6（包含）开始到最后
string.substring(0,6)  得到一个新的string,从0（包含）到6（不包含）
String[] arr=string.split(" ")把原始字符串以空格为界搞一个字符串数组

StringBuilder sb=new StringBuilder() 可以不声明stringbuilder的长度
sb.append()
sb.insert(i,数);




leetcode用不到的
Scanner sc=new Scanner(system.in);
while(sc.hasNext()){
  sc.next()  下一个String，见到空格或换行停止
  sc.nextLine()  下一个String，见到换行才停止
  sc.nextInt()  下一个int
}
