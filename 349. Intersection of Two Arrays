class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1=new HashSet<>();
        Set<Integer> set2=new HashSet<>();
        for(int i=0;i<nums1.length;i++){
            set1.add(nums1[i]);
        }
        for(int i=0;i<nums2.length;i++){
            if(set1.contains(nums2[i])){
                set2.add(nums2[i]);
            }
        }
        int k=0;
        int[] arr=new int[set2.size()];
        for(Integer num:set2){
            arr[k++]=num;
        }
        return arr;
    }
}

复杂度  1<logn<n<nlogn<n2
这个题用binarysearch的话是这样：先给nums2排序（Arrays.sort),然后对于nums1里的每一个元素在nums2里面binarysearch，找到的放进hashset里，然后转成数组
这样的话时间复杂度o nlogn (因为Arrays.sort)    空间复杂度o n(因为使用了hashset)
而不用binarysearch是这样：直接两个set，不用排序，nums1里的元素全放进set1,遍历nums2，如果set1.contains(nums[i]) 就放进set2
这样的话时间复杂度o n              空间复杂度o n

set的长度set.size()
set添加set.add()
set是否包含set.contains()
遍历set方法：for(Integer num:set)

